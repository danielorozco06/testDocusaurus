"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2016/10/03/jest-16","metadata":{"permalink":"/blog/2016/10/03/jest-16","editUrl":"https://github.com/jestjs/jest/tree/main/website/blog/2016-10-03-jest-16.md","source":"@site/blog/2016-10-03-jest-16.md","title":"Jest 16.0: Turbocharged CLI & Community Update","description":"It\'s been one month since the last major release and we\'ve made significant improvements to Jest since. In this major release we are updating the snapshot format we are using which will likely require snapshots to be updated when upgrading Jest. We don\'t make these changes lightly and don\'t expect this to happen often but we think it is necessary to improve the format from time to time.","date":"2016-10-03T00:00:00.000Z","formattedDate":"October 3, 2016","tags":[],"readingTime":5.84,"hasTruncateMarker":true,"authors":[{"name":"Christoph Nakazawa","url":"http://twitter.com/cpojer"}],"frontMatter":{"title":"Jest 16.0: Turbocharged CLI & Community Update","author":"Christoph Nakazawa","authorURL":"http://twitter.com/cpojer","authorFBID":100000023028168},"unlisted":false,"nextItem":{"title":"Jest 15.0: New Defaults for Jest","permalink":"/blog/2016/09/01/jest-15"}},"content":"It\'s been one month since the last major release and we\'ve made significant improvements to Jest since. In this major release we are updating the snapshot format we are using which will likely require snapshots to be updated when upgrading Jest. We don\'t make these changes lightly and don\'t expect this to happen often but we think it is necessary to improve the format from time to time.\\n\\n## Upgraded CLI\\n\\n![reporter](/img/blog/16-reporter.gif)\\n\\nJest 16 features a new reporter interface that shows running tests as well as a live summary and a progress bar based on the estimated test runtime from previous test runs. We also improved the CLI output to work better with different color schemes. If there were test failures in a previous run, Jest will now always run those tests first to give useful signal to users as quickly as possible.\\n\\n\x3c!--truncate--\x3e\\n\\nWe also added a lot of new features which you may find useful:\\n\\n- New CLI flags were added: A `--testNamePattern=pattern` or `-t <pattern>` option was added to filter tests from the command line much like `it.only` or `fit` does in tests.\\n- Previously failed tests now always run first.\\n- `jest <pattern>` is now case-insensitive to make it easier to filter test files.\\n- A test run in watch mode can now be interrupted. During a test run, simply press any of the keys used for input during watch mode (`a`, `o`, `p`, `q` or `enter`) to abort a test run and start a new one.\\n- The `--bail` flag now also works in watch mode. Together with running failed tests first, Jest\'s watch mode will now feel turbocharged!\\n- Jest now automatically considers files and tests with the `jsx` extension.\\n- Jest warns about duplicate manual mock files and we improved automatically created mocks for ES modules compiled with babel.\\n- A `jest.clearAllMocks` function was added to clear all mocks in between tests.\\n- We improved module resolution when `moduleNameMapper` is used.\\n- Finally, a `--findRelatedTests <fileA> <fileB>` cli option was added to run tests related to the specified files. This is especially helpful as a pre-commit hook if you\'d like to run tests only on a specified set of files that have tests associated with them.\\n\\nThis is what Jest looks like when a test run is interrupted in watch mode: ![watch](/img/blog/16-watch.gif)\\n\\n## Snapshot Updates\\n\\nJest\'s snapshot implementation was completely rewritten. The new version of the `jest-snapshot` package is now structured in a way that allows for easier integration into other test runners and enables more cool integrations like with [React Storybook](https://voice.kadira.io/snapshot-testing-in-react-storybook-43b3b71cec4f#.qh4lzcadb). Jest doesn\'t mark snapshots as obsolete in a file with skipped or failing tests. We also made a number of changes to the snapshot format:\\n\\n- Objects and Arrays are now printed with a trailing comma to minimize future changes to snapshots.\\n- We removed function names from snapshots. They were causing issues with different versions of Node, with code coverage instrumentation and we generally felt like it wasn\'t useful signal to show to the user that the name of a function has changed.\\n- Snapshots are now sorted using natural sort order within a file.\\n\\nWhen upgrading to Jest 16, the diff might look similar to this one: ![snapshots](/img/blog/16-snapshots.png)\\n\\n## Test Library Updates\\n\\nWe finished the migration of Jasmine assertions to the new Jest matchers. We added three new matchers: `toBeInstanceOf`, `toContainEqual` and `toThrowErrorMatchingSnapshot` . We have more readable failure messages for the spy/mock matchers `toHaveBeenLastCalledWith`, `toHaveBeenCalledWith`, `lastCalledWith` and `toBeCalledWith`. Now that we have rewritten all assertions and separated them into their own package, we\'ll be working on making them standalone so they can be integrated into any test framework if you\'d like to use them outside of Jest.\\n\\nWe also added a bunch of aliases that were requested by the community. To make Jest focus on a single test you can now use either `it.only` or `test.only` or keep using `fit`; For skipping a test, `it.skip` or `test.skip` are now available alongside of `xit`; finally to define a test as concurrent you can use `test.concurrent` which is useful in case your test accesses network resources or databases.\\n\\nFinally, if you\'d like to overwrite the `expect` global with a different assertion library like [chai](http://chaijs.com/), this can now be done using the `setupTestFrameworkScriptFile` configuration option.\\n\\n## Community Update\\n\\nOver the last month lots of articles were written about Jest\'s snapshot testing feature, how to migrate to Jest and how to get started writing tests. I also did a few live videos to explain how Jest and snapshot testing works:\\n\\n- [FB Live Video about Snapshot Testing](https://www.facebook.com/react/videos/1035427199869020/).\\n- [JavaScript & React Testing with Kent C. Dodds](https://www.youtube.com/watch?v=i31VtyJSM-I&feature=youtu.be).\\n\\nA number of people wrote articles about snapshot testing. The most opinionated article that resonated with the Jest team was \u201c[Testing with Jest Snapshots: First Impressions](http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/)\u201d. Ben makes three great points in his blog post:\\n\\n1.  Snapshot tests are a complement for conventional tests not a replacement.\\n2.  Snapshot tests are more useful with a healthy code review process.\\n3.  Snapshot tests work well with auto-mocking.\\n\\nWe highly recommend reading the entire blog post. Ben did a fantastic job explaining the reasons why we built snapshot testing. It\'s important to point out that we didn\'t introduce snapshot testing to replace all other forms of testing but rather as a way to enable engineers to write tests for code that they otherwise wouldn\'t write tests for. It works well for things like React components, CLI output, error messages and many others but it doesn\'t solve all problems. Jest\'s goal is to provide many different ways to write effective tests without sacrificing performance or the project\'s maintainability.\\n\\nOther highlights about snapshot testing:\\n\\n- A React Native testing series: [Part 1: Jest \u2013 Snapshot come into play](https://blog.callstack.io/unit-testing-react-native-with-the-new-jest-i-snapshots-come-into-play-68ba19b1b9fe) and [Part 2: Jest \u2013 Redux Snapshots for your Actions and Reducers](https://blog.callstack.io/unit-testing-react-native-with-the-new-jest-ii-redux-snapshots-for-your-actions-and-reducers-8559f6f8050b#.putt9eipm).\\n- [How we landed on Jest snapshot testing for JavaScript](https://blog.grommet.io/post/2016/09/01/how-we-landed-on-jest-snapshot-testing-for-javascript).\\n- [Picture This: Snapshot Testing](http://guigrpa.github.io/2016/09/27/picture-this-snapshot-testing/).\\n- [Snapshot testing with React Storybook](https://voice.kadira.io/snapshot-testing-in-react-storybook-43b3b71cec4f).\\n- [Testing React and Redux Applications](https://medium.com/@ryancollinsio/testing-react-redux-applications-fee79ac0087f#.lyjl7st1n).\\n- If you are using the popular [enzyme](https://github.com/airbnb/enzyme) testing utility, there is now a project [enzyme-to-json](https://github.com/trayio/enzyme-to-json) which makes it possible to use Jest\'s snapshot testing feature together with enzyme.\\n\\n[Redux itself now uses Jest](https://github.com/reactjs/redux/commit/7296d3cba1f5f899bdee5ef6695a8d21149f8d6c) and Max Stoiber wrote a [tutorial on how to test code written with redux](http://academy.plot.ly/react/6-testing/). There is also a great [guide on how to write tests for MobX](https://semaphoreci.com/community/tutorials/how-to-test-react-and-mobx-with-jest). If you are using [create-react-app](https://github.com/facebookincubator/create-react-app), Jest is now included by default. Kent C. Dodds created a ton of [videos on egghead.io](https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074) that will help you get started with Jest.\\n\\nIf you are using other test runners, Kenneth Skovhus built an awesome [jest-codemods](https://github.com/skovhus/jest-codemods) library that will automate the conversion for you. Codemods are awesome: they\'ll allow you to quickly evaluate whether Jest will work for you. Give it a try!\\n\\nThe full [changelog can be found on GitHub](https://github.com/jestjs/jest/blob/main/CHANGELOG.md#jest-1600). Jest 16 was a true JavaScript community effort and the project now has more than 220 contributors. We thank each and every one of you for your help to make this project great."},{"id":"/2016/09/01/jest-15","metadata":{"permalink":"/blog/2016/09/01/jest-15","editUrl":"https://github.com/jestjs/jest/tree/main/website/blog/2016-09-01-jest-15.md","source":"@site/blog/2016-09-01-jest-15.md","title":"Jest 15.0: New Defaults for Jest","description":"We spent the past year making Jest faster, easier to configure, added tons of features and built snapshot testing. However, there were two areas where we invested very little we can move fast and improve the framework for Facebook and the open source community at light-speed. Jest\'s goal is to come with batteries included and to require as little configuration as necessary. We recently got a chance to explain our philosophy on a create-react-app issue.","date":"2016-09-01T00:00:00.000Z","formattedDate":"September 1, 2016","tags":[],"readingTime":7.205,"hasTruncateMarker":true,"authors":[{"name":"Christoph Nakazawa","url":"http://twitter.com/cpojer"}],"frontMatter":{"title":"Jest 15.0: New Defaults for Jest","author":"Christoph Nakazawa","authorURL":"http://twitter.com/cpojer","authorFBID":100000023028168},"unlisted":false,"prevItem":{"title":"Jest 16.0: Turbocharged CLI & Community Update","permalink":"/blog/2016/10/03/jest-16"},"nextItem":{"title":"Jest 14.0: React Tree Snapshot Testing","permalink":"/blog/2016/07/27/jest-14"}},"content":"We spent the past year making Jest [faster](/blog/2016/03/11/javascript-unit-testing-performance), [easier to configure](/blog/2016/04/12/jest-11), [added tons of features](/blog/2016/06/22/jest-13) and built [snapshot testing](/blog/2016/07/27/jest-14). However, there were two areas where we invested very little: the CLI output and user experience. With Jest 15 we are changing the framework radically to make it easier to use both for beginners and experienced users. We are excited that our investment in Jest is now paying off: we can move fast and improve the framework for Facebook and the open source community at light-speed. Jest\'s goal is to come with batteries included and to require as little configuration as necessary. We recently got a chance to explain our philosophy on a [create-react-app issue](https://github.com/facebookincubator/create-react-app/pull/250#issuecomment-237098619).\\n\\nThe most important change to talk about is a set of [new defaults](https://github.com/jestjs/jest/pull/1511). If you are an existing Jest user you will very likely need to update your configuration for Jest 15. In most cases it will simplify your setup and Jest will provide useful error messages during the upgrade. All of the new defaults can be disabled to suit your needs, but we still consider the disabled features critical for Jest in certain situations and will continue to use and support them at Facebook long-term. Our [API documentation](/docs/api) was also completely rewritten to reflect these changes. [This pull request for React](https://github.com/facebook/react/pull/7625/files) highlights some of the changes necessary for existing projects.\\n\\n\x3c!--truncate--\x3e\\n\\n## New CLI error messages and summaries\\n\\nAs part of our effort to remove Jasmine incrementally within Jest, replacing all Jasmine matchers was almost completed. A lot of time was spent tweaking every error message for every matcher to give the best signal to users when a test is failing \u2013 the time when Jest should provide the most value to you. In addition to printing the expected and received values, a diff is printed for the `toBe` and `toEqual` matchers to help spot mistakes. More colors were added and relevant files from stack traces are highlighted more prominently.\\n\\nHere is a comparison of the before and after on a light terminal: ![failure1](/img/blog/15-failure1.png) It also works well with darker colors: ![failure2](/img/blog/15-failure2.png)\\n\\n## New watch command\\n\\nWe completely rewrote `jest --watch` to be more interactive. It can now switch between running all tests or only test files related to changed files by pressing `a` or `o`. By pressing `p` a prompt appears that allows to specify a test pattern to focus on a specific set of files. Snapshot tests can be updated by pressing `u`.\\n\\n![watch](/img/blog/15-watch.gif)\\n\\n## jest-react-native improvements\\n\\nMocks for `ListView`, `TextInput`, `ActivityIndicator`, `ScrollView` and more were added. The existing mocks were updated to use the real implementations and existing snapshots likely have to be updated when upgrading to Jest 15. A `mockComponent` function was added to `jest-react-native` that can be used to mock native components:\\n\\n```js\\njest.mock(\'MyNativeComponent\', () => {\\n  const jestReactNative = require(\'jest-react-native\');\\n  return jestReactNative.mockComponent(\'MyNativeComponent\');\\n});\\n```\\n\\nThere have also been a number of improvements around mocking images, the fetch module and other native APIs.\\n\\n## Buffered Console Messages\\n\\nJest parallelizes test runs across workers to maximize performance. Previously Jest used to forward console messages from workers to the parent and printed them immediately. When running multiple tests in parallel, it was often hard to find out which test and which module was calling a log function. In Jest 15, all console messages are buffered and printed together with individual test results. In addition the file and line number of the log call is printed so the code can easily be inspected.\\n\\nCompare the output of the previous version of Jest and Jest 15: ![console](/img/blog/15-console.png)\\n\\n## Disabled Automocking\\n\\nAutomocking is now disabled by default in Jest. This is by far the most confusing feature for new users and in many ways it doesn\'t make sense for small projects. We introduced automocking at Facebook and it worked great for us when unit testing was adopted in a large existing code base with few existing tests, but over time it felt like people spent more time fighting with mocked/unmocked modules than it would have taken them to write a test normally. We also noticed that library authors often require a huge number of basic modules that always have to be manually unmocked. Even for Jest itself we realized that the majority of tests had automocking disabled manually. We still believe that explicit automocking can be incredibly valuable. This change simply trades implicit mocks for explicit mocks via calls to `jest.mock(moduleName)`.\\n\\nIf you would still like to use automocking by default, enable the `automock` setting in your configuration or manually call `jest.enableAutomock()` in your test or setup file.\\n\\n## Test File Patterns\\n\\nNot everyone uses the same convention of using a `__tests__` folder to store tests. Jest 15 also looks for files ending in `.spec.js` or `.test.js`, two popular community standards. Jest 15 also removes the `testDirectoryName` and `testFileExtensions` configuration options and asks users to switch to the `testRegex` option when the old configuration options are used.\\n\\n## Module Registry Persistence\\n\\nJest used to implicitly reset all modules before each test and we recommended requiring modules in `beforeEach` or inside of tests. This is useful when modules have local state that shouldn\'t be shared between tests. However, two big shifts happened: ES modules with the top-level `import` syntax and a renewed interest in writing stateless functional modules.\\n\\nThis has lead to numerous incompatibilities. We also noticed that at Facebook we weren\'t even using this implicit reset. Instead we relied on explicit calls to `jest.resetModules()` which puts engineers in control on when to wipe away all state.\\n\\nHere is an example:\\n\\n```js\\nconst React1 = require(\'react\');\\njest.resetModules();\\nconst React2 = require(\'react\');\\n\\nReact1 !== React2; // These two are separate copies of React.\\n```\\n\\nThe call to `resetModules` wipes away the require cache. A second call to require the same module will result in a new instantiation of the same module and all of its dependencies. This feature is especially useful when dealing with modules that have side effects, like [jest-haste-map](https://github.com/jestjs/jest/blob/3bbf32a239fc4aad8cc6928a787f235bd86fecac/packages/jest-haste-map/src/__tests__/index-test.js#L64).\\n\\nWe believe it is better to put users in control so we disabled the implicit reset. Modules can be reset using `jest.resetModules()` in code and the `resetModules` option can be enabled in the configuration to bring back the previous behavior.\\n\\n## Real vs Fake Timers\\n\\nBy default Jest used to mock all timer functions like `setTimeout` or `process.nextTick` and provided an API `jest.runAllTimers()` to advance timers programatically. This is useful when a piece of code sets a long timeout that we don\'t want to wait for in a test.\\n\\nHowever we found that most of the time the use cases are quite isolated. [Async programming](/docs/tutorial-async) has also become much simpler in our test runner. Jest now uses the real timers by default.\\n\\nYou can still override this by specifying `\\"timers\\": \\"fake\\"` in the configuration or by calling `jest.useRealTimers()` and `jest.useFakeTimers()` global switches.\\n\\n## setupEnvScriptFile vs setupFiles\\n\\nThe `setupEnvScriptFile` configuration option has been deprecated for a while. Jest 15 removes it completely and replaces it with `setupFiles`. This option expects an array of file paths that are loaded in order before a test file is executed.\\n\\n## Rewritten Code Coverage Support\\n\\nCode coverage in Jest can be used through `jest --coverage` and requires no additional packages or configuration. Code coverage support was completely rewritten and a new `collectCoverageFrom` option was added to collect code coverage information from entire projects, including **untested files**. Note that this option uses globs as we are hoping to further simplify configuration options in the future and provide a simpler alternative to regular expressions. See Jest\'s [package.json](https://github.com/jestjs/jest/blob/9088f6517813f6c089cf52e980d6579511dcde88/package.json#L47) for an example.\\n\\n## Other Improvements\\n\\nA huge number of other improvements were also made:\\n\\n- Improved performance of small test runs.\\n- Jest now uses verbose mode when only a single test file is executed.\\n- Added an `--env` option to override the configured test environment.\\n- `moduleNameMapper` now uses a resolution algorithm.\\n- Jest now works with paths that have special characters in them, like parenthesis.\\n- Added `global.global` to the node environment.\\n- Fixed `babel-plugin-jest-hoist`\'s invalid error when a random user function was called `mock`.\\n- Fix `testEnvironment` resolution to prefer `jest-environment-{name}` instead of `{name}` only. This prevents a module collision when using `jsdom` as test environment.\\n- Improvements to Jest\'s own test infra by merging integration and unit tests. Code coverage is now collected for Jest.\\n\\nWe are happy when looking back at all the changes we have made together with the help from the community and couldn\'t be more excited to make Jest even better over the course of the next few months. Please [file an issue](https://github.com/jestjs/jest/issues) if something isn\'t working as expected and send us pull requests.\\n\\nNext up: [Concurrent Reporter](https://github.com/jestjs/jest/pull/1480)."},{"id":"/2016/07/27/jest-14","metadata":{"permalink":"/blog/2016/07/27/jest-14","editUrl":"https://github.com/jestjs/jest/tree/main/website/blog/2016-07-27-jest-14.md","source":"@site/blog/2016-07-27-jest-14.md","title":"Jest 14.0: React Tree Snapshot Testing","description":"One of Jest\'s philosophies is to provide an integrated \u201czero-configuration\u201d experience. We want to make it as frictionless as possible to write good tests that are useful. We observed that when engineers are provided with ready-to-use tools, they end up writing more tests, which in turn results in stable and healthy code bases.","date":"2016-07-27T00:00:00.000Z","formattedDate":"July 27, 2016","tags":[],"readingTime":5.355,"hasTruncateMarker":true,"authors":[{"name":"Christoph Nakazawa","url":"http://twitter.com/cpojer"}],"frontMatter":{"title":"Jest 14.0: React Tree Snapshot Testing","author":"Christoph Nakazawa","authorURL":"http://twitter.com/cpojer","authorFBID":100000023028168},"unlisted":false,"prevItem":{"title":"Jest 15.0: New Defaults for Jest","permalink":"/blog/2016/09/01/jest-15"},"nextItem":{"title":"Jest 13.0: Flow & REPL","permalink":"/blog/2016/06/22/jest-13"}},"content":"One of Jest\'s philosophies is to provide an integrated \u201czero-configuration\u201d experience. We want to make it as frictionless as possible to write good tests that are useful. We observed that when engineers are provided with ready-to-use tools, they end up writing more tests, which in turn results in stable and healthy code bases.\\n\\nOne of the big open questions was how to write React tests efficiently. There are plenty of tools such as [ReactTestUtils](https://facebook.github.io/react/docs/test-utils.html) and [enzyme](https://enzymejs.github.io/enzyme/). Both of these tools are great and are actively being used. However engineers frequently told us that they spend more time writing a test than the component itself. As a result many people stopped writing tests altogether which eventually led to instabilities. Engineers told us all they wanted was to make sure their components don\'t change unexpectedly.\\n\\n\x3c!--truncate--\x3e\\n\\nTogether with the React team we created a new test renderer for React and added snapshot testing to Jest. Consider this [example test](https://github.com/jestjs/jest/blob/main/examples/snapshot/__tests__/link.test.js) for a simple [Link component](https://github.com/jestjs/jest/blob/main/examples/snapshot/Link.js):\\n\\n```javascript\\nimport renderer from \'react-test-renderer\';\\ntest(\'Link renders correctly\', () => {\\n  const tree = renderer\\n    .create(<Link page=\\"http://www.facebook.com\\">Facebook</Link>)\\n    .toJSON();\\n  expect(tree).toMatchSnapshot();\\n});\\n```\\n\\nThe first time this test is run, Jest creates a [snapshot file](https://github.com/jestjs/jest/blob/main/examples/snapshot/__tests__/__snapshots__/link.test.js.snap) that looks like this:\\n\\n```javascript\\nexports[`Link renders correctly 1`] = `\\n<a\\n  className=\\"normal\\"\\n  href=\\"http://www.facebook.com\\"\\n  onMouseEnter={[Function bound _onMouseEnter]}\\n  onMouseLeave={[Function bound _onMouseLeave]}>\\n  Facebook\\n</a>\\n`;\\n```\\n\\nThe snapshot artifact should be committed alongside code changes. We use [pretty-format](https://github.com/thejameskyle/pretty-format) to make snapshots human-readable during code review. On subsequent test runs Jest will simply compare the rendered output with the previous snapshot. If they match, the test will pass. If they don\'t match, either the implementation has changed and the snapshot needs to be updated with `jest -u`, or the test runner found a bug in your code that should be fixed.\\n\\nIf we change the address the Link component in our example is pointing to, Jest will print this output:\\n\\n![snapshot-testing](/img/blog/snapshot.png)\\n\\nNow you know that you either need to accept the changes with `jest -u`, or fix the component if the changes were unintentional. To try out this functionality, please clone the [snapshot example](https://github.com/jestjs/jest/tree/main/examples/snapshot), modify the Link component and run Jest. We updated the [React Tutorial](/docs/tutorial-react) with a new guide for snapshot testing.\\n\\nThis feature was built by [Ben Alpert](https://twitter.com/soprano) and [Cristian Carlesso](https://twitter.com/kentaromiura).\\n\\n## Experimental React Native support\\n\\nBy building a test renderer that targets no specific platform we are finally able to support a full, unmocked version of React Native. We are excited to launch experimental React Native support for Jest through the `jest-react-native` package.\\n\\nYou can start using Jest with react-native by running `yarn add --dev jest-react-native` and by adding the preset to your Jest configuration:\\n\\n```json\\n\\"jest\\": {\\n  \\"preset\\": \\"jest-react-native\\"\\n}\\n```\\n\\n- [Tutorial and setup guide](/docs/tutorial-react-native#content)\\n- [Example project](https://github.com/jestjs/jest/tree/main/examples/react-native)\\n- [Example pull request for _snowflake_](https://github.com/bartonhammond/snowflake/pull/110), a popular react-native open source library.\\n\\n:::info\\n\\nThe preset currently only implements the minimal set of configuration necessary to get started with React Native testing. We are hoping for community contributions to improve this project. Please try it and file [issues](https://github.com/jestjs/jest/issues) or send pull requests!\\n\\n:::\\n\\n## Why snapshot testing?\\n\\nFor Facebook\'s native apps we use a system called \u201csnapshot testing\u201d: a snapshot test system that renders UI components, takes a screenshot and subsequently compares a recorded screenshot with changes made by an engineer. If the screenshots don\'t match, there are two possibilities: either the change is unexpected or the screenshot can be updated to the new version of the UI component.\\n\\nWhile this was the solution we wanted for the web, we also found many problems with such end-to-end tests that snapshot integration tests solve:\\n\\n- **No flakiness:** Because tests are run in a command line runner instead of a real browser or on a real phone, the test runner doesn\'t have to wait for builds, spawn browsers, load a page and drive the UI to get a component into the expected state which tends to be flaky and the test results become noisy.\\n- **Fast iteration speed:** Engineers want to get results in less than a second rather than waiting for minutes or even hours. If tests don\'t run quickly like in most end-to-end frameworks, engineers don\'t run them at all or don\'t bother writing them in the first place.\\n- **Debugging:** It\'s easy to step into the code of an integration test in JS instead of trying to recreate the screenshot test scenario and debugging what happened in the visual diff.\\n\\nBecause we believe snapshot testing can be useful beyond Jest we split the feature into a [jest-snapshot](https://github.com/jestjs/jest/tree/main/packages/jest-snapshot) package. We are happy to work with the community to make it more generic so it can be integrated with other test runners and share concepts and infrastructure with each other.\\n\\nFinally, here is a quote of a Facebook engineer describing how snapshot testing changed his unit testing experience:\\n\\n> \u201cOne of the most challenging aspects of my project was keeping the input and output files for each test case in sync. Each little change in functionality could cause all the output files to change. With snapshot testing I do not need the output files, the snapshots are generated for free by Jest! I can simply inspect how Jest updates the snapshots rather than making the changes manually.\u201d \u2013 [Kyle Davis](https://github.com/kyldvs) working on [fjs](https://github.com/kyldvs/fjs).\\n\\n## What\'s next for Jest\\n\\nRecently [Aaron Abramov](https://twitter.com/aarondjents) has joined the Jest team full time to improve our unit and integration test infrastructure for Facebook\'s ads products. For the next few months the Jest team is planning major improvements in these areas:\\n\\n- **Replace Jasmine:** Jasmine is slowing us down and is not being very actively developed. We started replacing all the Jasmine matchers and are excited to add new features and drop this dependency.\\n- **Code Coverage:** When Jest was originally created, tools such as babel didn\'t exist. Our code coverage support has a bunch of edge cases and isn\'t always working properly. We are rewriting it to address all the current problems with coverage.\\n- **Developer Experience:** This ranges from improving the setup process, the debugging experience to CLI improvements and more documentation.\\n- **Mocking:** The mocking system, especially around manual mocks, is not working well and is confusing. We hope to make it more strict and easier to understand.\\n- **Performance:** Further performance improvements especially for really large codebases are being worked on.\\n\\nAs always, if you have questions or if you are excited to help out, please reach out to us!"},{"id":"/2016/06/22/jest-13","metadata":{"permalink":"/blog/2016/06/22/jest-13","editUrl":"https://github.com/jestjs/jest/tree/main/website/blog/2016-06-22-jest-13.md","source":"@site/blog/2016-06-22-jest-13.md","title":"Jest 13.0: Flow & REPL","description":"Today we are happy to announce the next major release of Jest. We have made major changes to Jest which are going to benefit you and all of Facebook\'s JavaScript test infrastructure. Most importantly, we added static types to all of Jest\'s code during a recent Jest hackathon at Facebook. Fifteen people worked for a day and night to add Flow types to Jest and to add new features to Jest. The Flow types serve two purposes: First, we believe that code is written to be read. Most of the time, code is written only once but read by dozens of people over the course of years. Adding static types to the project helps document the code and helps explain some of the architecture in Jest. Second, adding static types makes maintenance easier and will allow us to more confidently refactor parts of Jest without fear of breakages.","date":"2016-06-22T00:00:00.000Z","formattedDate":"June 22, 2016","tags":[],"readingTime":2.565,"hasTruncateMarker":true,"authors":[{"name":"Christoph Nakazawa","url":"http://twitter.com/cpojer"}],"frontMatter":{"title":"Jest 13.0: Flow & REPL","author":"Christoph Nakazawa","authorURL":"http://twitter.com/cpojer","authorFBID":100000023028168},"unlisted":false,"prevItem":{"title":"Jest 14.0: React Tree Snapshot Testing","permalink":"/blog/2016/07/27/jest-14"},"nextItem":{"title":"Jest 11.0","permalink":"/blog/2016/04/12/jest-11"}},"content":"Today we are happy to announce the next major release of Jest. We have made major changes to Jest which are going to benefit you and all of Facebook\'s JavaScript test infrastructure. Most importantly, we added static types to all of Jest\'s code during a recent Jest hackathon at Facebook. Fifteen people worked for a day and night to add [Flow](https://flowtype.org/) types to Jest and to add new features to Jest. The Flow types serve two purposes: First, we believe that code is written to be read. Most of the time, code is written only once but read by dozens of people over the course of years. Adding static types to the project helps document the code and helps explain some of the architecture in Jest. Second, adding static types makes maintenance easier and will allow us to more confidently refactor parts of Jest without fear of breakages.\\n\\nThe Flow project has evolved a lot within Facebook and has been successfully adopted across many of our frameworks and almost all of our product code. Adoption can be parallelized incredibly well \u2013 it can be done file-by-file until enough of the codebase is well-typed. Then, Flow provides real value and helps guide through large changes. Through this, many small edge cases and bugs were found.\\n\\n\x3c!--truncate--\x3e\\n\\nWith the help of [lerna](https://github.com/lerna/lerna), we continued to modularize the Jest project. With just a small [update to the configuration](https://github.com/lerna/lerna#lernajson), Flow and lerna now get along well with each other. Splitting up Jest into packages helped us rethink module boundaries and enabled us to ship useful [packages](https://github.com/jestjs/jest/tree/main/packages) standalone: The `jest-runtime` and `jest-repl` cli tools now allow you to run scripts in a sandboxed Jest environment, enabling you to run and debug your app from the command line. This is especially helpful for projects that use Facebook\'s `@providesModule` module convention. To get started, just install `jest-repl` and run it in the same folder you normally run your tests in! We also published a `jest-changed-files` package that finds changed files in version control for either git or hg, a common thing in developer tools.\\n\\n## New and improved features\\n\\n- Added a notification plugin that shows a test run notification when using `--notify`.\\n- Added a `browser` config option to properly resolve npm packages with a browser field in `package.json` if you are writing tests for client side apps.\\n- Improved \u201cno tests found message\u201d which will now report which tests were found and how they were filtered.\\n- Added `jest.isMockFunction(jest.fn())` to test for mock functions.\\n- Improved test reporter printing and added a test failure summary when running many tests.\\n- Added support for mocking virtual modules through `jest.mock(\'Module\', implementation, {virtual: true})`.\\n- Removed the `.haste_cache` folder. Jest now uses the operating system\'s preferred temporary file location.\\n- Added the duration of individual tests in verbose mode.\\n- Added the ability to record snapshots in Jest. We\'ll be publishing a separate blog post about this feature soon.\\n\\nFinally, we have received a complete website redesign done by Matthew Johnston and added documentation for using [Jest with webpack](/docs/webpack). Happy Jesting!"},{"id":"/2016/04/12/jest-11","metadata":{"permalink":"/blog/2016/04/12/jest-11","editUrl":"https://github.com/jestjs/jest/tree/main/website/blog/2016-04-12-jest-11.md","source":"@site/blog/2016-04-12-jest-11.md","title":"Jest 11.0","description":"Today we\'re announcing a switch to major revisions for Jest with Jest 11.0 being the first major release. Jest has been used by Facebook engineers and on our continuous integration systems for years and we believe Jest has been way beyond a \u201c1.0 release\u201d for a long time. This is similar to a change the React team has made.","date":"2016-04-12T00:00:00.000Z","formattedDate":"April 12, 2016","tags":[],"readingTime":4.145,"hasTruncateMarker":true,"authors":[{"name":"Christoph Nakazawa","url":"http://twitter.com/cpojer"}],"frontMatter":{"title":"Jest 11.0","author":"Christoph Nakazawa","authorURL":"http://twitter.com/cpojer","authorFBID":100000023028168},"unlisted":false,"prevItem":{"title":"Jest 13.0: Flow & REPL","permalink":"/blog/2016/06/22/jest-13"},"nextItem":{"title":"JavaScript Unit Testing Performance","permalink":"/blog/2016/03/11/javascript-unit-testing-performance"}},"content":"Today we\'re announcing a switch to major revisions for Jest with Jest 11.0 being the first major release. Jest has been used by Facebook engineers and on our continuous integration systems for years and we believe Jest has been way beyond a \u201c1.0 release\u201d for a long time. This is similar to a change [the React team has made](http://facebook.github.io/react/blog/2016/02/19/new-versioning-scheme.html).\\n\\nIf you are using Jest 0.9 or Jest 0.10 the upgrade should be seamless. All changes from the last few months were rolled into Jest 11.0.\\n\\n### New in Jest 11.0\\n\\n#### Babel Integration and Simplified Setup\\n\\n`babel-jest` was adopted within the newly modularized Jest [repository](https://github.com/jestjs/jest/tree/main/packages) and it is now seamlessly integrated into Jest. If you are upgrading from an older version of Jest or are looking to adopt Jest, we recommend reading the [Getting Started guide](/docs/getting-started).\\n\\n\x3c!--truncate--\x3e\\n\\nPreviously Jest provided APIs such as `jest.dontMock` which unmocks a module that is subsequently being required using the `require` function. Testing code usually looked like this:\\n\\n```javascript\\njest.dontMock(\'LikeButton\');\\nconst LikeButton = require(\'LikeButton\'); // LikeButton is unmocked\\n```\\n\\nHowever, together with ES2015 import statements this will no longer work. Per the specification `import`s are hoisted to the top of their code block. Code written like this:\\n\\n```javascript\\njest.dontMock(\'LikeButton\');\\nimport LikeButton from \'LikeButton\';\\n```\\n\\nwhen executed, would actually be run in this order:\\n\\n```javascript\\nimport LikeButton from \'LikeButton\'; // This happens before the dontMock call.\\njest.dontMock(\'LikeButton\');\\n```\\n\\nThe LikeButton module would therefore be mocked even though we explicitly call `dontMock`.\\n\\nWhen the latest versions of Jest and babel-jest are used together, calls to the new APIs `jest.unmock`, `jest.mock`, `jest.disableAutomock` and `jest.enableAutomock` are hoisted to the top of their block, before ES2015 import statements.\\n\\n```javascript\\njest.unmock(\'LikeButton\');\\nimport LikeButton from \'LikeButton\'; // LikeButton is properly unmocked!\\n```\\n\\n#### (Auto)Mocking Improvements\\n\\nWe have made numerous improvements and bug fixes to Jest\'s automocking feature, improved npm3 support and added new manual mocking APIs. Many people have expressed a desire use Jest with the automocking feature disabled. A global configuration option [`automock`](/docs/api#automock-boolean), which can be set to `false`, was added.\\n\\nWe have also added two new APIs to simplify manual mocks. `jest.mock` specifies a manual mock factory for a specific test:\\n\\n```js\\n// Implement a mock for a hypothetical \\"sum\\" module.\\njest.mock(\'sum\', () => {\\n  return (a, b) => a + b;\\n});\\n\\nconst sum = require(\'sum\');\\nsum(1, 4); // 5\\n```\\n\\nAnd `jest.fn` was added to make it easier to create mock functions:\\n\\n```js\\n// Create a mock function\\nconst mockFn = jest.fn(() => 42);\\nmockFn(); // 42\\nexpect(mockFn.calls.length).toBe(1);\\n```\\n\\n#### Performance\\n\\nWe recently wrote about some [performance improvements](/blog/2016/03/11/javascript-unit-testing-performance) we\'ve made in Jest. Most notably, startup time has been improved and we are now in a comfortable place with regards to performance.\\n\\n#### Jasmine and Test Assertion Improvements\\n\\nWhen Jest was open sourced it shipped with Jasmine 1. Jest was designed to work with any test assertion library and optional Jasmine 2 support was added through an [external contribution](https://github.com/jestjs/jest/pull/330) at the end of last year. This change delivers better performance and provides a better APIs over the previous version of Jasmine. As such, we have converted all our JavaScript tests at Facebook to Jasmine 2. With Jest 11 we are making Jasmine 2 the new default. Jasmine 1 can be enabled through the [`testRunner`](/docs/api#testrunner-string) configuration option.\\n\\nWe have also made many updates around Jasmine. The failure messages for custom matchers provided for Jest\'s mock functions were improved and will now also work for Jasmine spies. Skipped tests, when using `fit` or `fdescribe,` are now properly reported at the end of a test run.\\n\\n#### Other Changes\\n\\nThe `jest --watch` command has been rewritten and improved. By default it now only runs tests related to changed files. If you want to run all tests on every change, you can run `jest --watch=all`. The verbose logger output has also been improved and we\'ve added more helpful warnings and error messages. We added a [`testEnvironment`](/docs/api#testenvironment-string) configuration option to customize the test environment. For example, when building a node service, a special `node` environment instead of `jsdom` can be used. Finally, the website and all documentation have been completely rewritten.\\n\\nAll changes from the past few months can be found in the [CHANGELOG](https://github.com/jestjs/jest/blob/main/CHANGELOG.md).\\n\\n### Contributions And Jest\'s future\\n\\nOver the last six months, Jest has received significant changes from a huge number of new contributors. I\'d like to thank all the open source contributors and Facebook employees for their help in making Jest better for everyone. New contributors: Alexander Juarez, Christian Lentfort, Cristian Carlesso, Dan Abramov, Dmitrii Abramov, Evan Jacobs, James Friend, James Ide, Jeff Carpenter, Joe Lencioni, Michael Diolosa, Nik Graf, Pavel Prokopenko, Pavel Volokitin, Sebastian Mayr and ShihChi Huang.\\n\\nWith your support we are looking forward to making Jest even better in the coming months. We are currently working on improved React (Native) testing, enhanced code coverage support and are planning to open source our internal test runner that allows multiple Jest projects to be run with a single run-command."},{"id":"/2016/03/11/javascript-unit-testing-performance","metadata":{"permalink":"/blog/2016/03/11/javascript-unit-testing-performance","editUrl":"https://github.com/jestjs/jest/tree/main/website/blog/2016-03-11-javascript-unit-testing-performance.md","source":"@site/blog/2016-03-11-javascript-unit-testing-performance.md","title":"JavaScript Unit Testing Performance","description":"Jest is running thousands of tests at Facebook at all times, either through continuous integration or invoked by engineers manually during development. This worked well for years even as the people working on Jest moved on to other projects within Facebook.","date":"2016-03-11T00:00:00.000Z","formattedDate":"March 11, 2016","tags":[],"readingTime":9.875,"hasTruncateMarker":true,"authors":[{"name":"Christoph Nakazawa","url":"http://twitter.com/cpojer"}],"frontMatter":{"title":"JavaScript Unit Testing Performance","author":"Christoph Nakazawa","authorURL":"http://twitter.com/cpojer","authorFBID":100000023028168},"unlisted":false,"prevItem":{"title":"Jest 11.0","permalink":"/blog/2016/04/12/jest-11"}},"content":"Jest is running thousands of tests at Facebook at all times, either through continuous integration or invoked by engineers manually during development. This worked well for years even as the people working on Jest moved on to other projects within Facebook.\\n\\nAs engineers added more and more tests though, we noticed the performance of Jest wasn\'t going to scale. Additionally, in the last year the JavaScript ecosystem has changed dramatically with the introduction of things like npm3 and Babel, which we hadn\'t anticipated. We formed a new Jest team to address all of these issues and we\'ll be sharing our progress and plans on this blog from now on.\\n\\n\x3c!--truncate--\x3e\\n\\nJest is a bit different from most test runners. We designed it to work well in the context of Facebook\'s infrastructure:\\n\\n- **Monorepo** At Facebook we have a huge monorepo that contains all of our JavaScript code. There are many reasons why this approach is advantageous for us and there is an [awesome talk](https://www.youtube.com/watch?v=W71BTkUbdqE) by a Google engineer that highlights all the benefits and drawbacks of monorepos.\\n- **Sandboxing** Another feature of Jest that\'s important to Facebook is how it virtualizes the test environment and wraps `require` in order to sandbox code execution and isolate individual tests. We\'re even working on making Jest more modular so we can take advantage of this functionality in other non-testing related use cases.\\n- **providesModule** If you\'ve looked at any of our open source JavaScript projects before, you may have noticed that we use a `@providesModule` header to assign globally unique IDs to modules. This does require some custom tooling, but it allows us to reference modules without relative paths which has helped us move incredibly fast, has scaled well as our engineering organization has grown, and has fostered code sharing across the entire company. Check out [RelayContainer](https://github.com/facebook/relay/blob/4eae620d86ed7fce1ee463c2fca88eb690d9cbde/src/container/RelayContainer.js#L9) for an example of how this works in practice. One downside to this approach, though, is that we\'re forced to read and parse our entire JavaScript codebase in order to resolve a single require statement. This would obviously be prohibitively expensive without extensive caching, especially for a short-lived process like Jest.\\n\\nAs a result of these unique constraints, Jest may never be able to be as fast as other test runners when running on our entire suite of tests. However, engineers rarely need to run Jest on our entire test suite. Powered by static analysis in the [node-haste](https://github.com/facebook/node-haste) project \u2013 we\'ve been able to make the default mode for running Jest at Facebook `jest --onlyChanged`, or `jest -o`. In this mode we build a reverse dependency graph to find only the affected tests that need to be run based on the modules that have been changed.\\n\\n## Optimal Scheduling of a Test Run\\n\\nMost of the time our static analysis determines that more than one test needs to be run. The number of affected tests can be anywhere from a couple of tests to thousands. In order to speed this process up Jest parallelizes test runs across workers. This is great because most of Facebook\'s development happens on remote servers with many CPU cores.\\n\\nRecently we noticed Jest often seemed stuck _\u201cWaiting for 3 tests\u201d_ for up to a minute toward the end of a run. It turned out we had a few really slow tests in our codebase that were dominating the test runtime. While we were able to speed these individual tests up significantly, we also made a change in how Jest schedules test runs. Previously we used to schedule test runs based on file system traversal, which was actually quite random. Here is an example of 11 tests in gray blocks over two workers. The size of the block is the runtime of the test:\\n\\n![perf-basic-scheduling](/img/blog/Scheduling1.png)\\n\\nWe were randomly running a mix of fast and slow tests, and one of our slowest tests ended up running as almost all the other tests were completed, during which the second worker sat idle.\\n\\nWe made a change to schedule tests based on their file size which is usually a good proxy for how long a test is going to take. A test with a few thousand lines of code likely takes longer than a test with 15 lines of code. While this sped up the entire test run by about 10%, we ended up finding a better heuristic: now Jest stores the runtime of each test in a cache and on subsequent runs, it schedules the slowest tests to run first. Overall this helped improve the runtime of all tests by about 20%.\\n\\nHere is an example of the same test run from before with better scheduling:\\n\\n![perf-improved-scheduling](/img/blog/Scheduling2.png)\\n\\nBecause we are running slow tests first, Jest can sometimes seem to take a long time to start up \u2013 we only print results after the first test has completed. For the future we are planning to run previously failed tests first, because getting that info to developers as quickly as possible matters the most.\\n\\n## Inline Requires and Lazy Mocking\\n\\nIf you have written tests using Jasmine before, they probably look like this:\\n\\n```js\\nconst sum = require(\'sum\');\\ndescribe(\'sum\', () => {\\n  it(\'works\', () => {\\n    expect(sum(5, 4)).toBe(9);\\n  });\\n});\\n```\\n\\nOne special thing we do in Jest is reset the entire module registry after every single test (call to `it`) to make sure tests don\'t depend on each other. Before Jest, individual tests would depend on each other and internal module state often leaked between them. As engineers removed, reordered or refactored tests, some of them started to fail, making it hard for people to understand what was going on.\\n\\nEvery single test in Jest receives a fresh new copy of all modules, including new versions of all mocked dependencies which take a lot of time to generate for each test. A side effect of this is that we had to call `require` manually before every test, like this:\\n\\n```js\\nlet sum;\\ndescribe(\'sum\', () => {\\n  beforeEach(() => {\\n    sum = require(\'sum\');\\n  });\\n  it(\'works\', () => {\\n    expect(sum(5, 4)).toBe(9);\\n  });\\n  it(\'works too\', () => {\\n    // This copy of sum is not the same as in the previous call to `it`.\\n    expect(sum(2, 3)).toBe(5);\\n  });\\n});\\n```\\n\\nWe built a babel transform called [inline-requires](https://github.com/facebook/fbjs/blob/main/packages/babel-preset-fbjs/plugins/inline-requires.js) that removes top-level require statements and inlines them in code. For example, the line `const sum = require(\'sum\');` will be removed from code, but every use of `sum` in the file will be replaced by `require(\'sum\')`. With this transform we can write tests just like you\'d expect in Jasmine and the code gets transformed into this:\\n\\n```js\\ndescribe(\'sum\', () => {\\n  it(\'works\', () => {\\n    expect(require(\'sum\')(5, 4)).toBe(9);\\n  });\\n});\\n```\\n\\nA great side-effect of inline requires is that we only require the modules that we actually use within the test itself, instead of all the modules we used in the entire file.\\n\\nWhich leads to another optimization: lazy mocking. The idea is to only mock modules on demand, which combined with inline requires saves us from mocking a lot of modules and all their recursive dependencies.\\n\\nWe were able to update all tests using a [codemod](https://github.com/cpojer/js-codemod/blob/master/transforms/outline-require.js) in no time \u2013 it was a _simple_ 50,000 line code change. Inline requires and lazy mocking improved the test runtime by 50%.\\n\\nThe inline-require babel plugin is not only useful for Jest but for normal JavaScript as well. It was shipped by [Bhuwan](https://twitter.com/voideanvalue) to all users of [facebook.com](http://facebook.com/) just a week ago and significantly improved startup time.\\n\\nFor now, if you\'d like to use this transform in Jest you\'ll have to add it manually to your Babel configuration. We are working on ways to make this easier to opt-in.\\n\\n## Repo-Sync and Caching\\n\\nThe open source version of Jest used to be a fork of our internal version, and we\'d sync Jest out only once every couple of months. This was a painful manual process that required fixing up many tests every time. We recently upgraded Jest and brought parity to all platforms (iOS, Android and web) and then enabled our sync process. Now, every change to Jest in open source is run against all of our internal tests, and there\'s only a single version of Jest that\'s consistent everywhere.\\n\\nThe first feature we got to take advantage of after unforking was the preprocessor cache. If you are using Babel together with Jest, Jest has to pre-process every JavaScript file before it can execute it. We built a caching layer so that each file, when unchanged, only has to be transformed a single time. After we unforked Jest, we were able to easily fix up the open source implementation and shipped it at Facebook. This resulted in another 50% performance win. Because the cache only works on the second-run, the cold start time of Jest was unaffected.\\n\\nWe also realized we were doing a lot of path operations when resolving relative requires. Because the module registry is reset for every test, there were thousands of calls that could be memoized. One big optimization was to add a lot more caching, not just around a single test, but also across test files. Previously, we would generate module metadata for the automocking feature once for every test file. The object a module exports never changes however, so we now share this code across test files. Unfortunately, because JavaScript and Node.js don\'t have shared memory, we have to do all of this work at least once per worker process.\\n\\n## Question Everything\\n\\nWhen trying to improve performance, it\'s important to also dive into the systems that sit above and below your system. In the case of Jest, things like Node.js and the test files themselves, for example. One of the first things we did was to update Node.js at Facebook from the years-old 0.10 to iojs and subsequently to Node 4. The new version of V8 helped improve performance and was quite easy to upgrade to.\\n\\nWe noticed that the `path` module in Node.js is slow when making thousands of path operations which was [fixed in Node 5.7](https://github.com/nodejs/node/pull/5123). Until we drop support for Node 4 internally at Facebook, we\'ll ship our own version of the [fastpath](https://github.com/facebook/node-haste/blob/master/src/fastpath.js) module.\\n\\nWe next started questioning the outdated [node-haste](https://github.com/facebook/node-haste). As mentioned before, the entire project has to be parsed for `@providesModule` headers to build a dependency graph. When this system was originally built, `node_modules` didn\'t exist and our file system crawler wasn\'t excluding them properly.\\n\\nIn previous versions, Jest would actually read every file in `node_modules` \u2013 which contributed to the slow startup time of Jest. When we picked up Jest again we replaced the entire project with a new implementation, based on react-native\'s packager. The startup time of Jest is now less than a second even on large projects. The react-native team, specifically [David](https://twitter.com/void_0), [Amjad](https://twitter.com/amasad) and [Martin](https://twitter.com/martinbigio) did an outstanding job on this project.\\n\\n## Adding everything up\\n\\nA lot of the above changes improved the test runtime by 10% or sometimes even 50%. We started at a runtime of about 10 minutes for all tests, and without these improvements we\'d probably be at around 20 minutes by now. After these improvements, though, it now consistently takes around 1 minute and 35 seconds to run all our tests!\\n\\nMore importantly, adding new tests causes total runtime to grow very slowly. Engineers can write and run more tests without feeling the costs.\\n\\nWith Jest\'s recent 0.9 release and performance improvements from the [node-haste2 integration](https://github.com/jestjs/jest/pull/599), the runtime of the [Relay](https://github.com/facebook/relay) framework\'s test suite went down from 60 seconds to about 25 and the [react-native](https://github.com/facebook/react-native) test suite now finishes in less than ten seconds on a 13\u201d MacBook Pro.\\n\\nWe\'re very happy with the wins we\'ve seen so far, and we\'re going to keep working on Jest and making it better. If you are curious about contributing to Jest, feel free get in touch on GitHub, [Discord](https://discord.gg/j6FKKQQrW9) or Facebook :)"}]}')}}]);